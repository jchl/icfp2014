const up = 0
const right = 1
const down = 2
const left = 3

const standard = 0
const fright = 1
const invisible = 2

const wall = 0
const empty = 1
const pill = 2
const power = 3
const fruit = 4
const lambda_start = 5
const ghost_start = 6

const followRight = 0
const followLeft = 1

fun mod4 move = if move > 3 then move - 4 else if move < 0 then move + 4 else move

fun opposite move = mod4 (move + 2)
fun turnright move = mod4 (move + 1)
fun turnleft move = mod4 (move - 1)

fun length xs = if null xs then 0 else 1 + length (tail xs)

fun lookup x xs = if x == (fst (head xs)) then snd (head xs) else lookup x (tail xs)
fun member x xs = if null xs then false else if x == (fst (head xs)) then true else member x (tail xs)

fun lookupBy eq x xs = if eq x (fst (head xs)) then snd (head xs) else lookupBy eq x (tail xs)
fun memberBy eq x xs = if null xs then false else if eq x (fst (head xs)) then true else memberBy eq x (tail xs)

fun map f xs = if null xs then [] else (f (head xs)) :: (map f (tail xs))
fun filter f xs = if null xs then [] else if f (head xs) then (head xs) :: (filter f (tail xs)) else filter f (tail xs)

fun fold f y xs = if null xs then y else fold f (f y (head xs)) (tail xs)
fun fold1 f xs = fold f (head xs) (tail xs)

fun all xs = fold (fn a b => a and b) true xs
fun any xs = fold (fn a b => a or b) false xs

fun max a b = if a > b then a else b

fun maximum xs = fold1 max xs

fun revappend xs ys = if null xs then ys else revappend (tail xs) ((head xs) :: ys)
fun rev xs = revappend xs []

fun append xs ys = if null xs then ys else (head xs) :: (append (tail xs) ys)

fun concat xs = if null xs then [] else append (head xs) (concat (tail xs))

fun nth n xs = if n == 0 then head xs else nth (n - 1) (tail xs)

fun mod a b = a - ((a / b) * b) ; Not sure if this is right (especially with negative numbers)...

fun randbool randsrc = mod (head randsrc) 2 == 0
fun randint randsrc n = mod (head randsrc) n

fun randomchoice randsrc xs = nth (randint randsrc (length xs)) xs

fun getcell' maze x y = nth x (nth y maze)

fun getcell maze loc =
  let (x, y) = loc in
    nth x (nth y maze)
  end

fun offset loc dir =
  let (x, y) = loc in
    if dir == up then (x, y - 1) else
    (if dir == down then (x, y + 1) else
     (if dir == left then (x - 1, y) else
      (if dir == right then (x + 1, y) else (x, y))))
  end

fun eqLoc loc1 loc2 =
  let (x1, y1) = loc1 in
  let (x2, y2) = loc2 in
    (x1 == x2) and (y1 == y2)
  end
  end

fun enqueue x q =
  let (qa, qb) = q in
    (x :: qa, qb)
  end

fun dequeue q =
  let (qa, qb) = q in
    if null qb then dequeue ([], rev qa)
    else (head qb, (qa, tail qb))
  end

fun nullq q =
  let (qa, qb) = q in
    (null qa) and (null qb)
  end

fun bfs start getNbrs eq stop =
  let frontier = ([start], []) in
  let visited = [(start, (0, 0))] in
  bfs' frontier visited getNbrs eq stop
  end
  end

fun bfs' frontier visited getNbrs eq stop =
  if nullq frontier then visited
  else
    let (x, frontier) = dequeue frontier in
    let (n, prev_) = lookupBy eq x visited in
      if stop (x, n) then
         visited
      else
        let nbrs = filter (fn y => not (memberBy eq y visited)) (getNbrs x) in
        let (frontier, visited) = fold (fn frontierAndVisited y =>
          let (frontier, visited) = frontierAndVisited in
          let frontier = enqueue y frontier in
          let visited = (y, (n + 1, x)) :: visited in
            (frontier, visited)
          end
          end
          end) (frontier, visited) nbrs in
          bfs' frontier visited getNbrs eq stop
        end
        end
    end
    end

fun dirScore maze ghostLocs ghostNextLocs myVitality myLocation dir =
  let newLocation = offset myLocation dir in
  let contents = getcell maze newLocation in
  let isGhost =
     (any (map (fn loc => eqLoc newLocation loc) ghostLocs)) or
     (any (map (fn loc => eqLoc newLocation loc) ghostNextLocs)) in
;  trace (newLocation, contents, isGhost) in
  let score =
    if (contents == wall) or
        ((myVitality < 300 {fudge factor!}) and isGhost) then 0
    else if isGhost then 10
    else if (contents == pill) then 3
    else if (contents == power) then 4
    else 2 in
    (score, dir)
  end
;  end
  end
  end
  end

fun allNbrs loc =
  let (x, y) = loc in
    [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]
  end

fun inBounds width height loc =
  let (x, y) = loc in
    (x >= 0) and (x < width) and (y >= 0) and (y < height)
  end

fun getNbrs loc maze =
  let height = length maze in
  let width = length (head maze) in
    filter (fn loc => getcell maze loc != wall) (filter (fn loc => inBounds width height loc) (allNbrs loc))
  end
  end

fun stepper state world =
  let (maze, myStatus, ghostsStatus, fruitTime) = world in
  let (myVitality, myLocation, myDirection, lives, score) = myStatus in
  let ghostLocs = map (fn ghostStatus => let (ghostVitality, ghostLocation, ghostDirection) = ghostStatus in ghostLocation end) ghostsStatus in
  let ghostNextLocs = map (fn ghostStatus => let (ghostVitality, ghostLocation, ghostDirection) = ghostStatus in offset ghostLocation ghostDirection end) ghostsStatus in
;  trace (1, myLocation, getcell maze myLocation) in
  let (nMoves, oldMove, followMode, movesSinceLike, startLocation, randsrc, randsrc_orig) = state in
  trace (nMoves, oldMove, followMode, movesSinceLike) in
  let randsrc = if null randsrc then randsrc_orig else randsrc in
;  let followMode = if eqLoc startLocation myLocation then 1 - followMode else followMode in
;  trace followMode in
; Pick a desired move
  let (move, like) =
    let fwdScore = dirScore maze ghostLocs ghostNextLocs myVitality myLocation oldMove in
    let bwdScore = (1, opposite oldMove) in
    let leftScore = dirScore maze ghostLocs ghostNextLocs myVitality myLocation (turnleft oldMove) in
    let rightScore = dirScore maze ghostLocs ghostNextLocs myVitality myLocation (turnright oldMove) in
    let scores = [fwdScore, bwdScore, leftScore, rightScore] in
;    trace scores in
    let maxscore = maximum (map (fn p => fst p) scores) in
    trace (maxscore, maxscore <= 2, maxscore > 2) in
      if (maxscore <= 2) and (movesSinceLike > 20) then
        trace 99 in
        let bfsResult = bfs myLocation (fn loc => getNbrs loc maze) eqLoc (fn x => let (loc, n) = x in n >= 5 end) in
          (oldMove, false)
        end
        end
      else
        trace 88 in
        let bestdirs = map (fn p => snd p) (filter (fn s => (fst s) == maxscore) scores) in
          (randomchoice randsrc bestdirs, maxscore > 2)
        end
        end
    end
    end
;    end
    end
    end
    end
    end
    end in
  trace (move, like) in
  let nMoves = nMoves + 1 in
  let movesSinceLike = if like then 0 else movesSinceLike + 1 in
  let state = (nMoves, move, followMode, movesSinceLike, startLocation, tail randsrc, randsrc_orig) in
    trace (nMoves, move, followMode, movesSinceLike) in (state, move) end
  end
  end
  end
  end
  end
;  end
;  end
  end
  end
  end
;  end
  end
  end
  end
  end

main world ghosts =
;  trace (66, 1 > 0, 0 > 1, 1 < 0, 0 < 1, 1 >= 0, 0 >= 1, 1 <= 0, 0 <= 1, 1 >= 1, 1 <= 1) in
; should be (66, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1) -- correct
;  trace bfs 17 (fn n => if n == 0 then [1] else if n == 20 then [19] else [n - 1, n + 1]) (fn a b => a == b) (fn x => false) in
  let (maze, myStatus, ghostsStatus, fruitTime) = world in
  let (myVitality, myLocation, myDirection, lives, score) = myStatus in
;  trace (0, myLocation, getcell maze myLocation) in
  let randsrc = [74382,2783,89234,234,892,23487,874,829043,7862,294,2094,29,2095,29083,2098,257,81,89,91,890453,234] in
  let state = (0, down, followRight, 0, myLocation, randsrc, randsrc) in
    (state, stepper)
  end
;  end
  end
  end
  end
;  end
;  end