const up = 0
const right = 1
const down = 2
const left = 3

const standard = 0
const fright = 1
const invisible = 2

const wall = 0
const empty = 1
const pill = 2
const power = 3
const fruit = 4
const lambda_start = 5
const ghost_start = 6

const followRight = 0
const followLeft = 1

fun mod4 move = if move > 3 then move - 4 else if move < 0 then move + 4 else move

fun opposite move = mod4 (move + 2)
fun turnright move = mod4 (move + 1)
fun turnleft move = mod4 (move - 1)

fun length xs = if null xs then 0 else 1 + length (tail xs)

fun map f xs = if null xs then [] else (f (head xs)) :: (map f (tail xs))

fun fold f y xs = if null xs then y else fold f (f y (head xs)) (tail xs)

fun all xs = fold (fn a b => a and b) true xs
fun any xs = fold (fn a b => a or b) false xs

fun revappend xs ys = if null xs then ys else revappend (tail xs) ((head xs) :: ys)
fun rev xs = revappend xs []

fun append xs ys = if null xs then ys else (head xs) :: (append (tail xs) ys)

fun concat xs = if null xs then [] else append (head xs) (concat (tail xs))

fun nth n xs = if n == 0 then head xs else nth (n - 1) (tail xs)

fun mod a b = a - ((a / b) * b) ; Not sure if this is right (especially with negative numbers)...

fun randbool randsrc = mod (head randsrc) 2 == 0

fun getcell' maze x y = nth x (nth y maze)

fun getcell maze loc =
  let (x, y) = loc in
    nth x (nth y maze)
  end

fun offset loc dir =
  let (x, y) = loc in
    if dir == up then (x, y - 1) else
    (if dir == down then (x, y + 1) else
     (if dir == left then (x - 1, y) else
      (if dir == right then (x + 1, y) else (x, y))))
  end

fun eqLoc loc1 loc2 =
  let (x1, y1) = loc1 in
  let (x2, y2) = loc2 in
    (x1 == x2) and (y1 == y2)
  end
  end

; fun selectDirection fwdScore rightScore leftScore =

fun okDir maze ghostLocs ghostNextLocs myVitality myLocation dir = ; Shouldn't avoid ghosts when in fright mode
  let newLocation = offset myLocation dir in
    (getcell maze newLocation != wall) and
    ((myVitality > 300) or ; fudge factor!
     ((not (any (map (fn loc => eqLoc newLocation loc) ghostLocs))) and
      (not (any (map (fn loc => eqLoc newLocation loc) ghostNextLocs)))))
  end

fun likeDir maze myLocation dir =
  let newLocation = offset myLocation dir in
  let contents = getcell maze newLocation in
    (contents == pill) or (contents == power)
  end
  end

fun stepper state world =
  let (maze, myStatus, ghostsStatus, fruitTime) = world in
  let (myVitality, myLocation, myDirection, lives, score) = myStatus in
  let ghostLocs = map (fn ghostStatus => let (ghostVitality, ghostLocation, ghostDirection) = ghostStatus in ghostLocation end) ghostsStatus in
  let ghostNextLocs = map (fn ghostStatus => let (ghostVitality, ghostLocation, ghostDirection) = ghostStatus in offset ghostLocation ghostDirection end) ghostsStatus in
;  trace (1, myLocation, getcell maze myLocation) in
  let (oldMove, followMode, startLocation, nMoves, randsrc, randsrc_orig) = state in
  let randsrc = if length randsrc < 3 then randsrc_orig else randsrc in
;  let followMode = if eqLoc startLocation myLocation then 1 - followMode else followMode in
;  trace followMode in
; Pick a desired move
  let move =
    let fwdOk = okDir maze ghostLocs ghostNextLocs myVitality myLocation oldMove in
    let rightOk = okDir maze ghostLocs ghostNextLocs myVitality myLocation (turnright oldMove) in
    let leftOk = okDir maze ghostLocs ghostNextLocs myVitality myLocation (turnleft oldMove) in
    let likeFwd = (likeDir maze myLocation oldMove) and fwdOk in
    let likeRight = (likeDir maze myLocation (turnright oldMove)) and rightOk in
    let likeLeft = (likeDir maze myLocation (turnleft oldMove)) and leftOk in
;    trace (fwdOk, rightOk, leftOk) in
    if not (likeRight or likeLeft or likeFwd) then
      if not (rightOk or leftOk or fwdOk) then opposite oldMove
      else if fwdOk then
        if leftOk and (randbool randsrc) then turnleft oldMove
        else if rightOk and (randbool (tail randsrc)) then turnright oldMove
        else oldMove
      else if rightOk then
        if leftOk and (randbool randsrc) then turnleft oldMove
        else turnright oldMove
      else
        turnleft oldMove
    else
      if likeFwd then
        if likeLeft and (randbool randsrc) then turnleft oldMove
        else if likeRight and (randbool (tail randsrc)) then turnright oldMove
        else oldMove
      else if likeRight then
        if likeLeft and (randbool randsrc) then turnleft oldMove
        else turnright oldMove
      else
        turnleft oldMove
  ;    end
    end
    end
    end
    end
    end
    end in
  let state = (move, followMode, startLocation, nMoves + 1, tail randsrc, randsrc_orig) in
    trace (state, move) in (state, move) end
  end
  end
;  end
;  end
  end
  end
;  end
  end
  end
  end
  end

main world ghosts =
  let (maze, myStatus, ghostsStatus, fruitTime) = world in
  let (myVitality, myLocation, myDirection, lives, score) = myStatus in
;  trace (0, myLocation, getcell maze myLocation) in
  let randsrc = [74382,2783,89234,234,892,23487,874,829043,7862,294,2094,29,2095,29083,2098,257,81,89,91,890453,234] in
  let state = (down, followRight, myLocation, 0, randsrc, randsrc) in
    (state, stepper)
  end
;  end
  end
  end
  end